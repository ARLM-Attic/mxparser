/**
* JTB file
*/

options {
  STATIC = false;
}

PARSER_BEGIN(SyntaxChecker)
namespace org.mariuszgromada.math.mxparser.syntaxchecker;

using System;
using System.IO;

public class SyntaxChecker {

  public void checkSyntax()  {    start();  }
  
}

PARSER_END(SyntaxChecker)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN : /* TOKENS */
{
	< #LETTER:		["_","a"-"z","A"-"Z"] >
| 	< #DIGIT:		["0"-"9"] >
| 	< #LETTERS:		<LETTER>(<LETTER >)* >
|  	< INTEGER:		<DIGIT>(<DIGIT>)* >
| 	< LEFT_PAR:	"(" >
| 	< RIGHT_PAR:	")" >
| 	< PLUS:	"+" >
| 	< MINUS:	"-" >
| 	< MULTIPLY:	"*" >
| 	< DIV:	"/" >
| 	< POWER:	"^" >
| 	< MODULO:	"#" >
| 	< FACTORIAL:	"!" >
| 	< COMMA:	"," >
| 	< SEMICOLON:	";" >
| 	< EQ:	( "=" | "==" ) >
| 	< UNIT:	( "[%]" | "[%%]" ) >
| 	< NEQ:	( "<>" | "!=" | "~=" ) >
| 	< LT:	"<" >
| 	< LEQ:	"<=" >
| 	< GT:	">"  >
| 	< GEQ:	">=" >
| 	< OR:	( "|" | "||" | "\\/" ) >
| 	< AND:	( "&" | "&&" | "/\\" ) >
| 	< NOT:	( "~" | "\u00ac" ) >
| 	< BITNOT:   "@~" >
| 	< IMP:	"-->" >
| 	< CIMP:	"<--" >
| 	< NIMP:	"-/>" >
| 	< CNIMP:"</-" >
|   < NAND: <NOT><AND> >
|   < EQV:  "<->" >
|   < NOR: <NOT><OR> >
|   < BIT: ( "@&" | "@^" | "@|" | "@<<" | "@>>" ) >
| 	< XOR:	"(+)" >
| 	< CHAR:	( "`"  | "@" | "#" | "$" | "." | "'" | ":" | ";" | "\\" | "/" | "?" )  >
}


TOKEN : /* NUMBER DECIMALS */
{
 	< REAL:
 				"." <INTEGER>
|  				<INTEGER> "."
|  				<INTEGER> "." <INTEGER>
	>
}



TOKEN : /* IDENTIFIER */
{
 	< IDENTIFIER:	<LETTERS> ( <LETTERS> | <INTEGER> )*  >
}

TOKEN : /* SPECIAL FUNCTION */
{
 	< FUNCTION: "der+" | "der-" >
}


void start():{}
{
  ( expression() (<EOF>) | <EOF > )
}
void expression():{ } 
{
  booleanExpression()
}
void booleanExpression():{ } 
{
  equalExpression() (
    						<OR> equalExpression()
    						| <AND> equalExpression()
    						| <NOR> equalExpression()
    						| <NAND> equalExpression()
    						| <XOR> equalExpression()
    						| <IMP> equalExpression()
    						| <CIMP> equalExpression()
    						| <NIMP> equalExpression()
    						| <CNIMP> equalExpression()
    						| <EQV> equalExpression()
							| <BIT> equalExpression()
  )* 
}
void equalExpression():{}
{
  relationalExpression() (	 <EQ> relationalExpression()
  							| <NEQ> relationalExpression()
  							| <GT> relationalExpression()
  							| <GEQ> relationalExpression()
  							| <LT> relationalExpression()
  							| <LEQ> relationalExpression()
  							)*
}
void relationalExpression():{}
{
  additiveExpression() 
}
void additiveExpression():{}
{
  multiplicativeExpression() ( <PLUS> multiplicativeExpression() | <MINUS> multiplicativeExpression() )* 
}
void multiplicativeExpression():{}
{
  unaryExpression() ( <POWER> unaryExpression() | <MULTIPLY> unaryExpression() | <DIV> unaryExpression() | <MODULO> unaryExpression() )* 
}
void unaryExpression():{}
{
  (<NOT> | <BITNOT>)? ( <PLUS> | <MINUS> )? ( realConstant() | ( identifier() | <FUNCTION> ) ( <LEFT_PAR> argumentList() <RIGHT_PAR> )? | <LEFT_PAR> expression() <RIGHT_PAR> ) ( <FACTORIAL> )?
}
void argumentList():{}
{
 ( expression() ( ( <COMMA> | <SEMICOLON> ) expression() )* )?
}
void identifier():{}
{
 (
   <IDENTIFIER> | <UNIT> | "[" ( <CHAR> | <IDENTIFIER> ( <NOT> | <MODULO> | <POWER> | <AND> | <MULTIPLY> | <DIV> | <LEFT_PAR> | <RIGHT_PAR> | <MINUS> | <PLUS> | <COMMA> | <OR> | <GT> | <LT> | <REAL> )* )+ "]" 
 )
}
void realConstant():{}
{
  ( <REAL> | <INTEGER> ) 
}

< * > TOKEN : 
{
< INVALID_TOKEN : "++" | "--" | "+-" | "-+" >  
|  < UNEXPECTED_CHAR : ~[] > 
} 